@startuml Modelisation

interface Ihm
{
    {abstract}+run()
    {abstract}+display()
    {abstract}+setViewA(Model.EntA)
    {abstract}+handle(..)
    {abstract}+...()
}

note bottom of ModelEntA : Model.EntA (static class)
class ModelEntA
{
    +<data>
}

note bottom of ModelEntB : Model.EntB (static class)
class ModelEntB
{
    +<data>
}

Model *-- ModelEntA
Model *-- ModelEntB
class Model
{
    +getEntA()
    +setEntA(Model.EntA)
    +checkOnWin()
    +..()
}

class AnimationFactory
{
    +{static}get..(..) : ..
}

class GraphicFactory
{
    +{static}get..(..) : ..
}

note bottom of IhmSfmlViewA : IhmSfml.ViewA (static class)
class IhmSfmlViewA
{
    -<data>
    -create()
    +set(..)
    +display()
}

note bottom of IhmSfmlViewB : IhmSfml.ViewB (static class)
class IhmSfmlViewB
{
    -<data>
    -create()
    +set(..)
    +display()
}

note bottom of IhmSfml : easily replacable
Ihm <|-- IhmSfml
IhmSfml *-- IhmSfmlViewA
IhmSfml *-- IhmSfmlViewB
GraphicFactory <-- IhmSfmlViewA : use
AnimationFactory <-- IhmSfmlViewA : use
class IhmSfml
{
    +run()
    +display()
    +setViewA(Model.EntA)
    +handle(..)
    +...()
}

interface Ai 
{
    {abstract} + nextMove()
}

note top of Ai : Strategy pattern
Ai 	<|-- Random
class Random
{
    + nextMove()
}

note left of MinMax : <b>nextMove</b> is a \ntemplate method
Ai 	<|-- MinMax
class MinMax
{
    + nextMove()
    - genTree()
    - evalNodes()
}

MinMax 	<|-- MinMaxMulti
class MinMaxMulti
{
    - genTree()
    - evalNodes()
}

MinMaxMulti *-- ThreadPool
class ThreadPool
{

}

note left of Controller : <b>updateView</b> updates\nViews based on Model
Controller *-- Model
Controller *--> Ihm
Controller *-- Ai
class Controller
{
    + run()
    + updateView()
    + UC1()
    +...()
}
@enduml